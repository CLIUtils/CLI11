# CLI11: Command line parser for C++11

![CLI11 Logo](./docs/CLI11_300.png)

[![Build Status Linux and macOS][travis-badge]][travis]
[![Build Status Windows][appveyor-badge]][appveyor]
[![Build Status Azure][azure-badge]][azure]
[![Code Coverage][codecov-badge]][codecov]
[![Codacy Badge][codacy-badge]][codacy-link]
[![Join the chat at https://gitter.im/CLI11gitter/Lobby][gitter-badge]][gitter]
[![License: BSD][license-badge]](./LICENSE)
[![Latest release][releases-badge]][github releases]
[![DOI][doi-badge]][doi-link]
[![Conan.io][conan-badge]][conan-link]
[![Try CLI11 1.8 online][wandbox-badge]][wandbox-link]

[What's new](./CHANGELOG.md) â€¢
[Documentation][gitbook] â€¢
[API Reference][api-docs]

CLI11 is a command line parser for C++11 and beyond that provides a rich feature set with a simple and intuitive interface.

## Table of Contents

-   [Background](#background)
    -   [Introduction](#introduction)
    -   [Why write another CLI parser?](#why-write-another-cli-parser)
    -   [Other parsers](#other-parsers)
    -   [Features not supported by this library](#features-not-supported-by-this-library)
-   [Install](#install)
-   [Usage](#usage)
    -   [Adding options](#adding-options)
        -   [Option types](#option-types)
        -   [Example](#example)
        -   [Option options](#option-options)
        -   [Validators](#validators) ðŸ†•
            -   [Transforming Validators](#transforming-validators) ðŸ†•
            -   [Validator operations](#validator-operations) ðŸ†•
            -   [Custom Validators](#custom-validators) ðŸ†•
            -   [Querying Validators](#querying-validators) ðŸ†•
        -   [Getting Results](#getting-results) ðŸ†•
    -   [Subcommands](#subcommands)
        -   [Subcommand options](#subcommand-options)
        -   [Option groups](#option-groups) ðŸ†•
        -   [Callbacks](#callbacks)
    -   [Configuration file](#configuration-file)
    -   [Inheriting defaults](#inheriting-defaults)
    -   [Formatting](#formatting)
    -   [Subclassing](#subclassing)
    -   [How it works](#how-it-works)
    -   [Utilities](#utilities)
    -   [Other libraries](#other-libraries)
-   [API](#api)
-   [Examples](#Examples)
-   [Contribute](#contribute)
-   [License](#license)

Features that were added in the last released major version are marked with "ðŸ†•". Features only available in master are marked with "ðŸ†•".

## Background

### Introduction

CLI11 provides all the features you expect in a powerful command line parser, with a beautiful, minimal syntax and no dependencies beyond C++11. It is header only, and comes in a single file form for easy inclusion in projects. It is easy to use for small projects, but powerful enough for complex command line projects, and can be customized for frameworks.
It is tested on [Travis][], [AppVeyor][], and [Azure][], and is being included in the [GooFit GPU fitting framework][goofit]. It was inspired by [`plumbum.cli`][plumbum] for Python. CLI11 has a user friendly introduction in this README, a more in-depth tutorial [GitBook][], as well as [API documentation][api-docs] generated by Travis.
See the [changelog](./CHANGELOG.md) or [GitHub Releases][] for details for current and past releases. Also see the [Version 1.0 post][], [Version 1.3 post][], or [Version 1.6 post][] for more information.

You can be notified when new releases are made by subscribing to <https://github.com/CLIUtils/CLI11/releases.atom> on an RSS reader, like Feedly, or use the releases mode of the github watching tool.

### Why write another CLI parser?

An acceptable CLI parser library should be all of the following:

-   Easy to include (i.e., header only, one file if possible, **no external requirements**).
-   Short, simple syntax: This is one of the main reasons to use a CLI parser, it should make variables from the command line nearly as easy to define as any other variables. If most of your program is hidden in CLI parsing, this is a problem for readability.
-   C++11 or better: Should work with GCC 4.8+ (default on CentOS/RHEL 7), Clang 3.4+, AppleClang 7+, NVCC 7.0+, or MSVC 2015+.
-   Work on Linux, macOS, and Windows.
-   Well tested using [Travis][] (Linux) and [AppVeyor][] (Windows) or [Azure][] (all three). "Well" is defined as having good coverage measured by [CodeCov][].
-   Clear help printing.
-   Nice error messages.
-   Standard shell idioms supported naturally, like grouping flags, a positional separator, etc.
-   Easy to execute, with help, parse errors, etc. providing correct exit and details.
-   Easy to extend as part of a framework that provides "applications" to users.
-   Usable subcommand syntax, with support for multiple subcommands, nested subcommands, option groups, and optional fallthrough (explained later).
-   Ability to add a configuration file (`ini` format), and produce it as well.
-   Produce real values that can be used directly in code, not something you have pay compute time to look up, for HPC applications.
-   Work with standard types, simple custom types, and extensible to exotic types.
-   Permissively licensed.

### Other parsers

<details><summary>The major CLI parsers for C++ include, with my biased opinions: (click to expand)</summary><p>

| Library                             | My biased opinion                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Boost Program Options][]           | A great library if you already depend on Boost, but its pre-C++11 syntax is really odd and setting up the correct call in the main function is poorly documented (and is nearly a page of code). A simple wrapper for the Boost library was originally developed, but was discarded as CLI11 became more powerful. The idea of capturing a value and setting it originated with Boost PO. [See this comparison.][cli11-po-compare] |
| [The Lean Mean C++ Option Parser][] | One header file is great, but the syntax is atrocious, in my opinion. It was quite impractical to wrap the syntax or to use in a complex project. It seems to handle standard parsing quite well.                                                                                                                                                                                                                                  |
| [TCLAP][]                           | The not-quite-standard command line parsing causes common shortcuts to fail. It also seems to be poorly supported, with only minimal bugfixes accepted. Header only, but in quite a few files. Has not managed to get enough support to move to GitHub yet. No subcommands. Produces wrapped values.                                                                                                                               |
| [Cxxopts][]                         | C++11, single file, and nice CMake support, but requires regex, therefore GCC 4.8 (CentOS 7 default) does not work. Syntax closely based on Boost PO, so not ideal but familiar.                                                                                                                                                                                                                                                   |
| [DocOpt][]                          | Completely different approach to program options in C++11, you write the docs and the interface is generated. Too fragile and specialized.                                                                                                                                                                                                                                                                                         |

After I wrote this, I also found the following libraries:

| Library                 | My biased opinion                                                                                                                                                                    |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [GFlags][]              | The Google Commandline Flags library. Uses macros heavily, and is limited in scope, missing things like subcommands. It provides a simple syntax and supports config files/env vars. |
| [GetOpt][]              | Very limited C solution with long, convoluted syntax. Does not support much of anything, like help generation. Always available on UNIX, though (but in different flavors).          |
| [ProgramOptions.hxx][]  | Interesting library, less powerful and no subcommands. Nice callback system.                                                                                                          |
| [Args][]                | Also interesting, and supports subcommands. I like the optional-like design, but CLI11 is cleaner and provides direct value access, and is less verbose.                             |
| [Argument Aggregator][] | I'm a big fan of the [fmt][] library, and the try-catch statement looks familiar.  :thumbsup: Doesn't seem to support subcommands.                                                   |
| [Clara][]               | Simple library built for the excellent [Catch][] testing framework. Unique syntax, limited scope.                                                                                    |
| [Argh!][]               | Very minimalistic C++11 parser, single header. Don't have many features. No help generation?!?! At least it's exception-free.                                                        |
| [CLI][]                 | Custom language and parser. Huge build-system overkill for very little benefit. Last release in 2009, but still occasionally active.  |
|[argparse][] | C++17 single file argument parser. Design seems similar to CLI11 in some ways. |

See [Awesome C++][] for a less-biased list of parsers. You can also find other single file libraries at [Single file libs][].

</p></details>
<br/>

None of these libraries fulfill all the above requirements, or really even come close. As you probably have already guessed, CLI11 does.
So, this library was designed to provide a great syntax, good compiler compatibility, and minimal installation fuss.

### Features not supported by this library

There are some other possible "features" that are intentionally not supported by this library:

-   Non-standard variations on syntax, like `-long` options. This is non-standard and should be avoided, so that is enforced by this library.
-   Completion of partial options, such as Python's `argparse` supplies for incomplete arguments. It's better not to guess. Most third party command line parsers for python actually reimplement command line parsing rather than using argparse because of this perceived design flaw.
-   Autocomplete: This might eventually be added to both Plumbum and CLI11, but it is not supported yet.
-   Wide strings / unicode: Since this uses the standard library only, it might be hard to properly implement, but I would be open to suggestions in how to do this.

## Install

To use, there are two methods:

1.  Copy `CLI11.hpp` from the [most recent release][github releases] into your include directory, and you are set. This is combined from the source files  for every release. This includes the entire command parser library, but does not include separate utilities (like `Timer`, `AutoTimer`). The utilities are completely self contained and can be copied separately.
2.  Use `CLI/*.hpp` files. You could check out the repository as a submodule, for example. You can use the `CLI11::CLI11` interface target when linking from `add_subdirectory`.
    You can also configure and optionally install the project, and then use `find_package(CLI11 CONFIG)` to get the `CLI11::CLI11` target. You can also use [Conan.io][conan-link] or [Hunter][].
    (These are just conveniences to allow you to use your favorite method of managing packages; it's just header only so including the correct path and
    using C++11 is all you really need.)

To build the tests, checkout the repository and use CMake:

```bash
mkdir build
cd build
cmake ..
make
GTEST_COLOR=1 CTEST_OUTPUT_ON_FAILURE=1 make test
```

## Usage

### Adding options

To set up, add options, and run, your main function will look something like this:

```cpp
int main(int charc, char** argv) {
    CLI::App app{"App description"};

    std::string filename = "default";
    app.add_option("-f,--file", filename, "A help string");

    CLI11_PARSE(app, argc, argv);
    return 0;
}
```

<details><summary>Note: If you don't like macros, this is what that macro expands to: (click to expand)</summary><p>

```cpp
try {
    app.parse(argc, argv);
} catch (const CLI::ParseError &e) {
    return app.exit(e);
}
```

The try/catch block ensures that `-h,--help` or a parse error will exit with the correct return code (selected from `CLI::ExitCodes`). (The return here should be inside `main`). You should not assume that the option values have been set inside the catch block; for example, help flags intentionally short-circuit all other processing for speed and to ensure required options and the like do not interfere.

</p></details>
</br>

The initialization is just one line, adding options is just two each. The parse macro is just one line (or 5 for the contents of the macro).  After the app runs, the filename will be set to the correct value if it was passed, otherwise it will be set to the default. You can check to see if this was passed on the command line with `app.count("--file")`.

#### Option types

While all options internally are the same type, there are several ways to add an option depending on what you need. The supported values are:

```cpp
// Add options
app.add_option(option_name, help_str="") // ðŸ†•

app.add_option(option_name,
               variable_to_bind_to, // bool, int, float, vector, ðŸ†• enum, or string-like, or anything with a defined conversion from a string
               help_string="")

app.add_option_function<type>(option_name,
               function <void(const type &value)>, // ðŸ†• int, bool, float, enum, vector, or string-like, or anything with a defined conversion from a string
               help_string="")

app.add_complex(... // Special case: support for complex numbers

// Add flags
app.add_flag(option_name,
             help_string="")

app.add_flag(option_name,
             variable_to_bind_to, // bool, int, ðŸ†• float, ðŸ†• vector, ðŸ†• enum, or ðŸ†• string-like, or ðŸ†• anything with a defined conversion from a string
             help_string="")

app.add_flag_function(option_name, // ðŸ†•
             function <void(int64_t count)>,
             help_string="")

app.add_flag_callback(option_name,function<void(void)>,help_string="") // ðŸ†•

// Add subcommands
App* subcom = app.add_subcommand(name, description);

Option_group *app.add_option_group(name,description); // ðŸ†•

// âš ï¸  All add_*set* methods deprecated in CLI11 1.8 - use ->transform(CLI::IsMember) instead
-app.add_set(option_name,
-            variable_to_bind_to,     // Same type as stored by set
-            set_of_possible_options, // Set will be copied, ignores changes
-            help_string="")
-app.add_mutable_set(... // Set can change later, keeps reference
-app.add_set_ignore_case(...                    // String only
-app.add_mutable_set_ignore_case(...            // String only
-app.add_set_ignore_underscore(...              // String only
-app.add_mutable_set_ignore_underscore(...      // String only
-app.add_set_ignore_case_underscore(...         // String only
-app.add_mutable_set_ignore_case_underscore(... // String only
```

An option name must start with a alphabetic character, underscore, a number ðŸ†•, '?' ðŸ†•, or '@' ðŸ†•. For long options, after the first character '.', and '-' are also valid characters. For the `add_flag*` functions '{' has special meaning. Names are given as a comma separated string, with the dash or dashes. An option or flag can have as many names as you want, and afterward, using `count`, you can use any of the names, with dashes as needed, to count the options. One of the names is allowed to be given without proceeding dash(es); if present the option is a positional option, and that name will be used on the help line for its positional form.

The `add_option_function<type>(...` function will typically require the template parameter be given unless a `std::function` object with an exact match is passed.  The type can be any type supported by the `add_option` function. The function should throw an error (`CLI::ConversionError` or `CLI::ValidationError` possibly) if the value is not valid.

ðŸ†• Flag options specified through the `add_flag*` functions allow a syntax for the option names to default particular options to a false value or any other value if some flags are passed.  For example:

```cpp
app.add_flag("--flag,!--no-flag",result,"help for flag"); // ðŸ†•
```

specifies that if `--flag` is passed on the command line result will be true or contain a value of 1. If `--no-flag` is
passed `result` will contain false or -1 if `result` is a signed integer type, or 0 if it is an unsigned type.  An
alternative form of the syntax is more explicit: `"--flag,--no-flag{false}"`; this is equivalent to the previous
example.  This also works for short form options `"-f,!-n"` or `"-f,-n{false}"`. If `variable_to_bind_to` is anything but an integer value the
default behavior is to take the last value given, while if `variable_to_bind_to` is an integer type the behavior will be to sum
all the given arguments and return the result.  This can be modified if needed by changing the `multi_option_policy` on each flag (this is not inherited).
The default value can be any value. For example if you wished to define a numerical flag:

```cpp
app.add_flag("-1{1},-2{2},-3{3}",result,"numerical flag") // ðŸ†•
```

using any of those flags on the command line will result in the specified number in the output.  Similar things can be done for string values, and enumerations, as long as the default value can be converted to the given type.


On a `C++14` compiler, you can pass a callback function directly to `.add_flag`, while in C++11 mode you'll need to use `.add_flag_function` if you want a callback function. The function will be given the number of times the flag was passed. You can throw a relevant `CLI::ParseError` to signal a failure.

On a compiler that supports C++17's `__has_include`, you can also use `std::optional`, `std::experimental::optional`, and `boost::optional` directly in an `add_option` call. If you don't have `__has_include`, you can define `CLI11_BOOST_OPTIONAL 1` before including CLI11 to manually add support (or 0 to remove) for `boost::optional`. See [CLI11 Internals][] for information on how this was done and how you can add your own converters.  Optional values are only supported for types that support the `>>` operator.

#### Example

-   `"one,-o,--one"`: Valid as long as not a flag, would create an option that can be specified positionally, or with `-o` or `--one`
-   `"this"` Can only be passed positionally
-   `"-a,-b,-c"` No limit to the number of non-positional option names

The add commands return a pointer to an internally stored `Option`.
This option can be used directly to check for the count (`->count()`) after parsing to avoid a string based lookup.
âš ï¸  Deprecated: The `add_*` commands have a final argument than can be set to true, which causes the default value to be captured and printed on the command line with the help flag. Since CLI11 1.8, you can simply add `->capture_default_str()`.

#### Option options

Before parsing, you can set the following options:

-   `->required()`: The program will quit if this option is not present. This is `mandatory` in Plumbum, but required options seems to be a more standard term. For compatibility, `->mandatory()` also works.
-   `->expected(N)`: Take `N` values instead of as many as possible, only for vector args. If negative, require at least `-N`; end with `--` or another recognized option or subcommand.
-   `->type_name(typename)`: Set the name of an Option's type (`type_name_fn` allows a function instead)
-   `->type_size(N)`: Set the intrinsic size of an option. The parser will require multiples of this number if negative.
-   `->needs(opt)`: This option requires another option to also be present, opt is an `Option` pointer.
-   `->excludes(opt)`: This option cannot be given with `opt` present, opt is an `Option` pointer.
-   `->envname(name)`: Gets the value from the environment if present and not passed on the command line.
-   `->group(name)`: The help group to put the option in. No effect for positional options. Defaults to `"Options"`. `""` will not show up in the help print (hidden).
-   `->ignore_case()`: Ignore the case on the command line (also works on subcommands, does not affect arguments).
-   `->ignore_underscore()`: Ignore any underscores in the options names (also works on subcommands, does not affect arguments). For example "option_one" will match with "optionone".  This does not apply to short form options since they only have one character
-   `->disable_flag_override()`: ðŸ†• From the command line long form flag options can be assigned a value on the command line using the `=` notation `--flag=value`. If this behavior is not desired, the `disable_flag_override()` disables it and will generate an exception if it is done on the command line.  The `=` does not work with short form flag options.
-    `->delimiter(char)`: ðŸ†• allows specification of a custom delimiter for separating single arguments into vector arguments, for example specifying `->delimiter(',')` on an option would result in `--opt=1,2,3` producing 3 elements of a vector and the equivalent of --opt 1 2 3 assuming opt is a vector value.
-   `->description(str)`: Set/change the description.
-   `->multi_option_policy(CLI::MultiOptionPolicy::Throw)`: Set the multi-option policy. Shortcuts available: `->take_last()`, `->take_first()`, and `->join()`. This will only affect options expecting 1 argument or bool flags (which do not inherit their default but always start with a specific policy).
-   `->check(std::string(const std::string &), validator_name="",validator_description="")`: ðŸ†• Define a check function.  The function should return a non empty string with the error message if the check fails
-   `->check(Validator)`:ðŸ†• Use a Validator object to do the check see [Validators](#validators) for a description of available Validators and how to create new ones.
-   `->transform(std::string(std::string &), validator_name="",validator_description=")`: Converts the input string into the output string, in-place in the parsed options.
-   `->transform(Validator)`: uses a Validator object to do the transformation see [Validators](#validators) for a description of available Validators and how to create new ones.
-   `->each(void(const std::string &)>`: Run this function on each value received, as it is received. It should throw a `ValidationError` if an error is encountered.
-   `->configurable(false)`: Disable this option from being in a configuration file.
    `->capture_default_str()`: ðŸ†• Store the current value attached and display it in the help string.
    `->default_function(std::string())`: ðŸ†• Advanced: Change the function that `capture_default_str()` uses.
    `->always_capture_default()`: ðŸ†• Always run `capture_default_str()` when creating new options. Only useful on an App's `option_defaults`.


These options return the `Option` pointer, so you can chain them together, and even skip storing the pointer entirely. The `each` function takes any function that has the signature `void(const std::string&)`; it should throw a `ValidationError` when validation fails. The help message will have the name of the parent option prepended. Since `each`, `check` and `transform` use the same underlying mechanism, you can chain as many as you want, and they will be executed in order. Operations added through `transform` are executed first in reverse order of addition, and `check` and `each` are run following the transform functions in order of addition. If you just want to see the unconverted values, use `.results()` to get the `std::vector<std::string>` of results.

On the command line, options can be given as:

-   `-a` (flag)
-   `-abc` (flags can be combined)
-   `-f filename` (option)
-   `-ffilename` (no space required)
-   `-abcf filename` (flags and option can be combined)
-   `--long` (long flag)
-   `--long_flag=true` (long flag with equals to override default value) ðŸ†•
-   `--file filename` (space)
-   `--file=filename` (equals)

If `allow_windows_style_options()` is specified in the application or subcommand options can also be given as:
-   `/a` (flag)
-   `/f filename` (option)
-   `/long` (long flag)
-   `/file filename` (space)
-   `/file:filename` (colon)
-   `/long_flag:false` (long flag with : to override the default value) ðŸ†•
=  Windows style options do not allow combining short options or values not separated from the short option like with `-` options

ðŸ†• Long flag options may be given with an `=<value>` to allow specifying a false value, or some other value to the flag. See [config files](#configuration-file) for details on the values supported.  NOTE: only the `=` or `:` for windows-style options may be used for this, using a space will result in the argument being interpreted as a positional argument.  This syntax can override the default values, and can be disabled by using `disable_flag_override()`.

Extra positional arguments will cause the program to exit, so at least one positional option with a vector is recommended if you want to allow extraneous arguments.
If you set `.allow_extras()` on the main `App`, you will not get an error. You can access the missing options using `remaining` (if you have subcommands, `app.remaining(true)` will get all remaining options, subcommands included).
If the remaining arguments are to processed by another `App` then the function `remaining_for_passthrough()` ðŸ†• can be used to get the remaining arguments in reverse order such that `app.parse(vector)` works directly and could even be used inside a subcommand callback.

You can access a vector of pointers to the parsed options in the original order using `parse_order()`.
If `--` is present in the command line that does not end an unlimited option, then
everything after that is positional only.

#### Validators
Validators are structures to check or modify inputs, they can be used to verify that an input meets certain criteria or transform it into another value.  They are added through the `check` or `transform` functions.  The differences between the two function are that checks do not modify the input whereas transforms can and are executed before any Validators added through `check`.

CLI11 has several Validators built-in that perform some common checks

-   `CLI::IsMember(...)`: ðŸ†• Require an option be a member of a given set.  See [Transforming Validators](#transforming-validators) for more details.
-   `CLI::Transformer(...)`: ðŸ†• Modify the input using a map.  See [Transforming Validators](#transforming-validators) for more details.
-   `CLI::CheckedTransformer(...)`: ðŸ†• Modify the input using a map, and require that the input is either in the set or already one of the outputs of the set. See [Transforming Validators](#transforming-validators) for more details.
-   `CLI::AsNumberWithUnit(...)`:ðŸ†• Modify the `<NUMBER> <UNIT>` pair by matching the unit and multiplying the number by the corresponding factor. It can be used as a base for transformers, that accept things like size values (`1 KB`) or durations (`0.33 ms`).
-   `CLI::AsSizeValue(...)`: ðŸ†• Convert inputs like `100b`, `42 KB`, `101 Mb`, `11 Mib` to absolute values. `KB` can be configured to be interpreted as 10^3 or 2^10.
-   `CLI::ExistingFile`: Requires that the file exists if given.
-   `CLI::ExistingDirectory`: Requires that the directory exists.
-   `CLI::ExistingPath`: Requires that the path (file or directory) exists.
-   `CLI::NonexistentPath`: Requires that the path does not exist.
-   `CLI::Range(min,max)`: Requires that the option be between min and max (make sure to use floating point if needed). Min defaults to 0.
-   `CLI::Bounded(min,max)`: ðŸ†• Modify the input such that it is always between min and max (make sure to use floating point if needed). Min defaults to 0.  Will produce an error if conversion is not possible.
-   `CLI::PositiveNumber`: ðŸ†• Requires the number be greater or equal to 0
-   `CLI::Number`: ðŸ†• Requires the input be a number.
-   `CLI::ValidIPV4`: ðŸ†• Requires that the option be a valid IPv4 string e.g. `'255.255.255.255'`, `'10.1.1.7'`.

These Validators can be used by simply passing the name into the `check` or `transform` methods on an option

```cpp
->check(CLI::ExistingFile);
->check(CLI::Range(0,10));
```

Validators can be merged using `&` and `|` and inverted using `!` ðŸ†•. For example:

```cpp
->check(CLI::Range(0,10)|CLI::Range(20,30));
```

will produce a check to ensure a value is between 0 and 10 or 20 and 30.

```cpp
->check(!CLI::PositiveNumber);
```

will produce a check for a number less than 0.

##### Transforming Validators
There are a few built in Validators that let you transform values if used with the `transform` function.  If they also do some checks then they can be used `check` but some may do nothing in that case.
 * ðŸ†• `CLI::Bounded(min,max)` will bound values between min and max and values outside of that range are limited to min or max,  it will fail if the value cannot be converted and produce a `ValidationError`
 * ðŸ†• The `IsMember` Validator lets you specify a set of predefined options. You can pass any container or copyable pointer (including `std::shared_ptr`) to a container to this validator; the container just needs to be iterable and have a `::value_type`. The key type should be convertible from a string,  You can use an initializer list directly if you like. If you need to modify the set later, the pointer form lets you do that; the type message and check will correctly refer to the current version of the set.  The container passed in can be a set, vector, or a map like structure. If used in the `transform` method the output value will be the matching key as it could be modified by filters.
After specifying a set of options, you can also specify "filter" functions of the form `T(T)`, where `T` is the type of the values. The most common choices probably will be `CLI::ignore_case` an `CLI::ignore_underscore`, and `CLI::ignore_space`.  These all work on strings but it is possible to define functions that work on other types.
Here are some examples
of `IsMember`:

     *   `CLI::IsMember({"choice1", "choice2"})`: Select from exact match to choices.
     *   `CLI::IsMember({"choice1", "choice2"}, CLI::ignore_case, CLI::ignore_underscore)`: Match things like `Choice_1`, too.
     *  `CLI::IsMember(std::set<int>({2,3,4}))`: Most containers and types work; you just need `std::begin`, `std::end`, and `::value_type`.
     *   `CLI::IsMember(std::map<std::string, TYPE>({{"one", 1}, {"two", 2}}))`: You can use maps; in `->transform()` these replace the matched value with the matched key.  The value member of the map is not used in `IsMember`, so it can be any type.
     *   `auto p = std::make_shared<std::vector<std::string>>(std::initializer_list<std::string>("one", "two")); CLI::IsMember(p)`: You can modify `p` later.
* ðŸ†• The `Transformer` and `CheckedTransformer` Validators transform one value into another. Any container or copyable pointer (including `std::shared_ptr`) to a container that generates pairs of values can be passed to these `Validator's`; the container just needs to be iterable and have a `::value_type` that consists of pairs. The key type should be convertible from a string, and the value type should be convertible to a string  You can use an initializer list directly if you like. If you need to modify the map later, the pointer form lets you do that; the description message will correctly refer to the current version of the map.  `Transformer` does not do any checking so values not in the map are ignored.  `CheckedTransformer` takes an extra step of verifying that the value is either one of the map key values, in which case it is transformed, or one of the expected output values, and if not will generate a `ValidationError`.  A Transformer placed using `check` will not do anything.
After specifying a map of options, you can also specify "filter" just like in `CLI::IsMember`.
Here are some examples (`Transformer` and `CheckedTransformer` are interchangeable in the examples)
of `Transformer`:

     *   `CLI::Transformer({{"key1", "map1"},{"key2","map2"}})`: Select from key values and produce map values.

     *  `CLI::Transformer(std::map<std::string,int>({"two",2},{"three",3},{"four",4}}))`: most maplike containers work,  the `::value_type` needs to produce a pair of some kind.
     *   `CLI::CheckedTransformer(std::map<std::string, int>({{"one", 1}, {"two", 2}}))`: You can use maps; in `->transform()` these replace the matched key with the value.  `CheckedTransformer` also requires that the value either match one of the keys or match one of known outputs.
     *   `auto p = std::make_shared<CLI::TransformPairs<std::string>>(std::initializer_list<std::pair<std::string,std::string>>({"key1", "map1"},{"key2","map2"})); CLI::Transformer(p)`: You can modify `p` later. `TransformPairs<T>` is an alias for `std::vector<std::pair<<std::string,T>>`

NOTES:  If the container used in `IsMember`, `Transformer`, or `CheckedTransformer` has a `find` function like `std::unordered_map`  or `std::map` then that function is used to do the searching. If it does not have a `find` function a linear search is performed.  If there are filters present, the fast search is performed first, and if that fails a linear search with the filters on the key values is performed.

##### Validator operations ðŸ†•
Validators are copyable and have a few operations that can be performed on them to alter settings.  Most of the built in Validators have a default description that is displayed in the help.  This can be altered via `.description(validator_description)`.
The name of a Validator, which is useful for later reference from the `get_validator(name)` method of an `Option` can be set via `.name(validator_name)`
The operation function of a Validator can be set via
`.operation(std::function<std::string(std::string &>)`.  The `.active()` function can activate or deactivate a Validator from the operation.
All the functions return a Validator reference allowing them to be chained.  For example

```cpp
opt->check(CLI::Range(10,20).description("range is limited to sensible values").active(false).name("range"));
```

will specify a check on an option with a name "range", but deactivate it for the time being.
The check can later be activated through

```cpp
opt->get_validator("range")->active();
```

##### Custom Validators ðŸ†•

A validator object with a custom function can be created via

```cpp
CLI::Validator(std::function<std::string(std::string &)>,validator_description,validator_name="");
```

or if the operation function is set later they can be created with

```cpp
CLI::Validator(validator_description);
```

 It is also possible to create a subclass of `CLI::Validator`, in which case it can also set a custom description function, and operation function.

##### Querying Validators ðŸ†•

Once loaded into an Option, a pointer to a named Validator can be retrieved via

```cpp
opt->get_validator(name);
```

This will retrieve a Validator with the given name or throw a `CLI::OptionNotFound` error.  If no name is given or name is empty the first unnamed Validator will be returned or the first Validator if there is only one.

Validators have a few functions to query the current values
 * `get_description()`: ðŸ†• Will return a description string
 * `get_name()`: ðŸ†• Will return the Validator name
 * `get_active()`: ðŸ†• Will return the current active state, true if the Validator is active.
 * `get_modifying()`: ðŸ†• Will return true if the Validator is allowed to modify the input, this can be controlled via the `non_modifying()` ðŸ†• method, though it is recommended to let `check` and `transform` option methods manipulate it if needed.

#### Getting results

In most cases, the fastest and easiest way is to return the results through a callback or variable specified in one of the `add_*` functions.  But there are situations where this is not possible or desired.  For these cases the results may be obtained through one of the following functions. Please note that these functions will do any type conversions and processing during the call so should not used in performance critical code:

- `results()`: Retrieves a vector of strings with all the results in the order they were given.
- `results(variable_to_bind_to)`: ðŸ†• Gets the results according to the MultiOptionPolicy and converts them just like the `add_option_function` with a variable.
- `Value=as<type>()`: ðŸ†• Returns the result or default value directly as the specified type if possible, can be vector to return all results, and a non-vector to get the result according to the MultiOptionPolicy in place.

### Subcommands

Subcommands are supported, and can be nested infinitely. To add a subcommand, call the `add_subcommand` method with a name and an optional description. This gives a pointer to an `App` that behaves just like the main app, and can take options or further subcommands. Add `->ignore_case()` to a subcommand to allow any variation of caps to also be accepted. `->ignore_underscore()` is similar, but for underscores. Children inherit the current setting from the parent. You cannot add multiple matching subcommand names at the same level (including `ignore_case` and `ignore_underscore`).

If you want to require that at least one subcommand is given, use `.require_subcommand()` on the parent app. You can optionally give an exact number of subcommands to require, as well. If you give two arguments, that sets the min and max number allowed.
0 for the max number allowed will allow an unlimited number of subcommands. As a handy shortcut, a single negative value N will set "up to N" values. Limiting the maximum number allows you to keep arguments that match a previous
subcommand name from matching.

If an `App` (main or subcommand) has been parsed on the command line, `->parsed` will be true (or convert directly to bool).
All `App`s have a `get_subcommands()` method, which returns a list of pointers to the subcommands passed on the command line. A `got_subcommand(App_or_name)` method is also provided that will check to see if an `App` pointer or a string name was collected on the command line.

For many cases, however, using an app's callback may be easier. Every app executes a callback function after it parses; just use a lambda function (with capture to get parsed values) to `.callback`. If you throw `CLI::Success` or `CLI::RuntimeError(return_value)`, you can
even exit the program through the callback. The main `App` has a callback slot, as well, but it is generally not as useful.
You are allowed to throw `CLI::Success` in the callbacks.
Multiple subcommands are allowed, to allow [`Click`][click] like series of commands (order is preserved).  ðŸ†• The same subcommand can be triggered multiple times but all positional arguments will take precedence over the second and future calls of the subcommand.  `->count()` on the subcommand will return the number of times the subcommand was called.  The subcommand callback will only be triggered once unless the `.immediate_callback()`  ðŸ†• flag is set.  In which case the callback executes on completion of the subcommand arguments but after the arguments for that subcommand have been parsed, and can be triggered multiple times.

ðŸ†• Subcommands may also have an empty name either by calling `add_subcommand` with an empty string for the name or with no arguments.
Nameless subcommands function a similarly to groups in the main `App`. See [Option groups](#option-groups) to see how this might work.  If an option is not defined in the main App, all nameless subcommands are checked as well.  This allows for the options to be defined in a composable group.  The `add_subcommand` function has an overload for adding a `shared_ptr<App>` so the subcommand(s) could be defined in different components and merged into a main `App`, or possibly multiple `Apps`.  Multiple nameless subcommands are allowed.  Callbacks for nameless subcommands are only triggered if any options from the subcommand were parsed.

#### Subcommand options

There are several options that are supported on the main app and subcommands and option_groups. These are:

-   `.ignore_case()`: Ignore the case of this subcommand. Inherited by added subcommands, so is usually used on the main `App`.
-   `.ignore_underscore()`: Ignore any underscores in the subcommand name. Inherited by added subcommands, so is usually used on the main `App`.
-   `.allow_windows_style_options()`: Allow command line options to be parsed in the form of `/s /long /file:file_name.ext`  This option does not change how options are specified in the `add_option` calls or the ability to process options in the form of `-s --long --file=file_name.ext`.
-   `.fallthrough()`: Allow extra unmatched options and positionals to "fall through" and be matched on a parent command. Subcommands always are allowed to fall through.
-   `.disable()`: ðŸ†• Specify that the subcommand is disabled, if given with a bool value it will enable or disable the subcommand or option group.
-   `.disabled_by_default()`: ðŸ†• Specify that at the start of parsing the subcommand/option_group should be disabled. This is useful for allowing some Subcommands to trigger others.
-   `.enabled_by_default()`: ðŸ†• Specify that at the start of each parse the subcommand/option_group should be enabled.  This is useful for allowing some Subcommands to disable others.
-   `.validate_positionals()`: ðŸ†• Specify that positionals should pass validation before matching.  Validation is specified through `transform`, `check`, and `each` for an option.  If an argument fails validation it is not an error and matching proceeds to the next available positional or extra arguments.
-   `.excludes(option_or_subcommand)`: ðŸ†• If given an option pointer or pointer to another subcommand, these subcommands cannot be given together.  In the case of options, if the option is passed the subcommand cannot be used and will generate an error.
-   `.require_option()`: ðŸ†• Require 1 or more options or option groups be used.
-   `.require_option(N)`: ðŸ†• Require `N` options or option groups, if `N>0`, or up to `N` if `N<0`. `N=0` resets to the default to 0 or more.
-   `.require_option(min, max)`: ðŸ†• Explicitly set min and max allowed options or option groups. Setting `max` to 0 implies unlimited options.
-   `.require_subcommand()`: Require 1 or more subcommands.
-   `.require_subcommand(N)`: Require `N` subcommands if `N>0`, or up to `N` if `N<0`. `N=0` resets to the default to 0 or more.
-   `.require_subcommand(min, max)`: Explicitly set min and max allowed subcommands. Setting `max` to 0 is unlimited.
-   `.add_subcommand(name="", description="")`: Add a subcommand, returns a pointer to the internally stored subcommand.
-   `.add_subcommand(shared_ptr<App>)`: ðŸ†• Add a subcommand by shared_ptr, returns a pointer to the internally stored subcommand.
-   `.remove_subcommand(App)`: ðŸ†• Remove a subcommand from the app or subcommand.
-   `.got_subcommand(App_or_name)`: Check to see if a subcommand was received on the command line.
-   `.get_subcommands(filter)`: The list of subcommands that match a particular filter function.
-   `.add_option_group(name="", description="")`: ðŸ†• Add an [option group](#option-groups) to an App,  an option group is specialized subcommand intended for containing groups of options or other groups for controlling how options interact.
-   `.get_parent()`: Get the parent App or `nullptr` if called on master App.
-   `.get_option(name)`: Get an option pointer by option name will throw if the specified option is not available,  nameless subcommands are also searched
-   `.get_option_no_throw(name)`: ðŸ†• Get an option pointer by option name. This function will return a `nullptr` instead of throwing if the option is not available.
-   `.get_options(filter)`: Get the list of all defined option pointers (useful for processing the app for custom output formats).
-   `.parse_order()`: Get the list of option pointers in the order they were parsed (including duplicates).
-   `.formatter(fmt)`: Set a formatter, with signature `std::string(const App*, std::string, AppFormatMode)`. See Formatting for more details.
-   `.description(str)`: Set/change the description.
-   `.get_description()`: Access the description.
-   `.parsed()`: True if this subcommand was given on the command line.
-   `.count()`: Returns the number of times the subcommand was called.
-   `.count(option_name)`: Returns the number of times a particular option was called.
-   `.count_all()`: ðŸ†• Returns the total number of arguments a particular subcommand processed, on the master App it returns the total number of processed commands.
-   `.name(name)`: Add or change the name.
-   `.callback(void() function)`: Set the callback that runs at the end of parsing. The options have already run at this point. See [Subcommand callbacks](#callbacks) for some additional details.
-   `.immediate_callback()`: ðŸ†• Specify that the callback for a subcommand should run immediately on completion of a subcommand vs at the completion of all parsing if this option is not used.
-    `.pre_parse_callback(void(size_t) function)`: ðŸ†• Set a callback that executes after the first argument of an application is processed.  See [Subcommand callbacks](#callbacks) for some additional details.
-   `.allow_extras()`: Do not throw an error if extra arguments are left over.
-   `.positionals_at_end()`: ðŸ†• Specify that positional arguments occur as the last arguments and throw an error if an unexpected positional is encountered.
-   `.prefix_command()`: Like `allow_extras`, but stop immediately on the first unrecognized item. It is ideal for allowing your app or subcommand to be a "prefix" to calling another app.
-   `.footer(message)`: Set text to appear at the bottom of the help string.
-   `.set_help_flag(name, message)`: Set the help flag name and message, returns a pointer to the created option.
-   `.set_help_all_flag(name, message)`: Set the help all flag name and message, returns a pointer to the created option. Expands subcommands.
-   `.failure_message(func)`: Set the failure message function. Two provided: `CLI::FailureMessage::help` and `CLI::FailureMessage::simple` (the default).
-   `.group(name)`: Set a group name, defaults to `"Subcommands"`. Setting `""` will be hide the subcommand.
- `[option_name]`: ðŸ†• retrieve a const pointer to an option given by `option_name` for Example `app["--flag1"]` will get a pointer to the option for the "--flag1" value,  `app["--flag1"]->as<bool>()` will get the results of the command line for a flag. The operation will throw an exception if the option name is not valid.

> Note: if you have a fixed number of required positional options, that will match before subcommand names. `{}` is an empty filter function, and any positional argument will match before repeated subcommand names.


#### Callbacks
A subcommand has two optional callbacks that are executed at different stages of processing.  The `preparse_callback` ðŸ†• is executed once after the first argument of a subcommand or application is processed and gives an argument for the number of remaining arguments to process.  For the main app the first argument is considered the program name,  for subcommands the first argument is the subcommand name.  For Option groups and nameless subcommands the first argument is after the first argument or subcommand is processed from that group.
The second callback is executed after parsing.  The behavior depends on the status of the `immediate_callback` flag ðŸ†•. If true, this runs immediately after the parsing of the subcommand.  Or if the flag is false, once after parsing of all arguments.  If the `immediate_callback` is set then the callback can be executed multiple times if the subcommand list given multiple times.  If the main app or subcommand has a config file, no data from the config file will be reflected in immediate_callback. `immediate_callback()` has no effect on the main app, though it can be inherited.  For option_groups `immediate_callback` causes the callback to be run prior to other option groups and options in the main app, effectively giving the options in the group priority.

For example say an application was set up like

```cpp
app.callback(ac);
sub1=app.add_subcommand("sub1")->callback(c1)->preparse_callback(pc1)->immediate_callback();
sub2=app.add_subcommand("sub2")->callback(c2)->preparse_callback(pc2);
app.preparse_callback( pa);

... A bunch of other options

```

Then the command line is given as

```
program --opt1 opt1_val  sub1 --sub1opt --sub1optb val sub2 --sub2opt sub1 --sub1opt2 sub2 --sub2opt2 val
```

* pa will be called prior to parsing any values with an argument of 13.
* pc1 will be called immediately after processing the sub1 command with a value of 10.
* c1 will be called when the `sub2` command is encountered.
* pc2 will be called with value of 6 after the sub2 command is encountered.
* c1 will be called again after the second sub2 command is encountered.
* c2 will be called once after processing all arguments.
* ac will be called after completing the parse and all lower level callbacks have been executed.

A subcommand is considered terminated when one of the following conditions are met.
1. There are no more arguments to process
2. Another subcommand is encountered that would not fit in an optional slot of the subcommand
3. The positional_mark(`--`) is encountered and there are no available positional slots in the subcommand.
4. The subcommand_terminator mark(`++`) is encountered

If the `immediate_callback` flag is set then all contained options are processed and the callback is triggered.  If a subcommand with an `immediate_callback` flag is called again, then the contained options are reset, and can be triggered again.



#### Option groups ðŸ†•

The subcommand method

```cpp
.add_option_group(name,description)
```

Will create an option group, and return a pointer to it.  An option group allows creation of a collection of options, similar to the groups function on options, but with additional controls and requirements.  They allow specific sets of options to be composed and controlled as a collective.  For an example see [range test](./tests/ranges.cpp).  Option groups are a specialization of an App so all [functions](#subcommand-options) that work with an App or subcommand also work on option groups.  Options can be created as part of an option group using the add functions just like a subcommand, or previously created options can be added through

```cpp
ogroup->add_option(option_pointer);
ogroup->add_options(option_pointer);
ogroup->add_options(option1,option2,option3,...);
```

The option pointers used in this function must be options defined in the parent application of the option group otherwise an error will be generated.  Subcommands can also be added via

```cpp
ogroup->add_subcommand(subcom_pointer);
```

This results in the subcommand being moved from its parent into the option group.

Options in an option group are searched for a command line match after any options in the main app, so any positionals in the main app would be matched first.  So care must be taken to make sure of the order when using positional arguments and option groups.
Option groups work well with `excludes` and `require_options` methods, as an application will treat an option group as a single option for the purpose of counting and requirements, and an option group will be considered used if any of the options or subcommands contained in it are used.  Option groups allow specifying requirements such as requiring 1 of 3 options in one group and 1 of 3 options in a different group. Option groups can contain other groups as well.   Disabling an option group will turn off all options within the group.

The `CLI::TriggerOn` ðŸ†• and `CLI::TriggerOff` ðŸ†• methods are helper methods to allow the use of options/subcommands from one group to trigger another group on or off.

```cpp
CLI::TriggerOn(group1_pointer, triggered_group);
CLI::TriggerOff(group2_pointer, disabled_group);
```

These functions make use of `preparse_callback`, `enabled_by_default()` and `disabled_by_default`.  The triggered group may be a vector of group pointers.  These methods should only be used once per group and will override any previous use of the underlying functions.  More complex arrangements can be accomplished using similar methodology with a custom preparse_callback function that does more.


### Configuration file

```cpp
app.set_config(option_name="",
               default_file_name="",
               help_string="Read an ini file",
               required=false)
```

If this is called with no arguments, it will remove the configuration file option (like `set_help_flag`). Setting a configuration option is special. If it is present, it will be read along with the normal command line arguments. The file will be read if it exists, and does not throw an error unless `required` is `true`. Configuration files are in `ini` format by default (other formats can be added by an adept user). An example of a file:

```ini
; Comments are supported, using a ;
; The default section is [default], case insensitive

value = 1
str = "A string"
vector = 1 2 3
str_vector = "one" "two" "and three"

; Sections map to subcommands
[subcommand]
in_subcommand = Wow
sub.subcommand = true
```

Spaces before and after the name and argument are ignored. Multiple arguments are separated by spaces. One set of quotes will be removed, preserving spaces (the same way the command line works). Boolean options can be `true`, `on`, `1`, `yes`, ðŸ†• `enable`; or `false`, `off`, `0`, `no`, ðŸ†• `disable` (case insensitive). Sections (and `.` separated names) are treated as subcommands (note: this does not mean that subcommand was passed, it just sets the "defaults". You cannot set positional-only arguments or force subcommands to be present in the command line.

To print a configuration file from the passed
arguments, use `.config_to_str(default_also=false, prefix="", write_description=false)`, where `default_also` will also show any defaulted arguments, `prefix` will add a prefix, and `write_description` will include option descriptions.

### Inheriting defaults

Many of the defaults for subcommands and even options are inherited from their creators. The inherited default values for subcommands are `allow_extras`, `prefix_command`, `ignore_case`, `ignore_underscore`, `fallthrough`, `group`, `footer`,`immediate_callback` and maximum number of required subcommands. The help flag existence, name, and description are inherited, as well.

Options have defaults for `group`, `required`, `multi_option_policy`, `ignore_case`, `ignore_underscore`, ðŸ†• `delimiter`, and ðŸ†• `disable_flag_override`. To set these defaults, you should set the `option_defaults()` object, for example:

```cpp
app.option_defaults()->required();
// All future options will be required
```

The default settings for options are inherited to subcommands, as well.

### Formatting

The job of formatting help printouts is delegated to a formatter callable object on Apps and Options. You are free to replace either formatter by calling `formatter(fmt)` on an `App`, where fmt is any copyable callable with the correct signature.
CLI11 comes with a default App formatter functional, `Formatter`. It is customizable; you can set `label(key, value)` to replace the default labels like `REQUIRED`, and `column_width(n)` to set the width of the columns before you add the functional to the app or option. You can also override almost any stage of the formatting process in a subclass of either formatter. If you want to make a new formatter from scratch, you can do
that too; you just need to implement the correct signature. The first argument is a const pointer to the in question. The formatter will get a `std::string` usage name as the second option, and a `AppFormatMode` mode for the final option. It should return a `std::string`.

The `AppFormatMode` can be `Normal`, `All`, or `Sub`, and it indicates the situation the help was called in. `Sub` is optional, but the default formatter uses it to make sure expanded subcommands are called with
their own formatter since you can't access anything but the call operator once a formatter has been set.

### Subclassing

The App class was designed allow toolkits to subclass it, to provide preset default options (see above) and setup/teardown code. Subcommands remain an unsubclassed `App`, since those are not expected to need setup and teardown. The default `App` only adds a help flag, `-h,--help`, than can removed/replaced using `.set_help_flag(name, help_string)`. You can also set a help-all flag with `.set_help_all_flag(name, help_string)`; this will expand the subcommands (one level only). You can remove options if you have pointers to them using `.remove_option(opt)`. You can add a `pre_callback` override to customize the after parse
but before run behavior, while
still giving the user freedom to `callback` on the main app.

The most important parse function is `parse(std::vector<std::string>)`, which takes a reversed list of arguments (so that `pop_back` processes the args in the correct order). `get_help_ptr` and `get_config_ptr` give you access to the help/config option pointers. The standard `parse` manually sets the name from the first argument, so it should not be in this vector. You can also use `parse(string, bool)` to split up and parse a string; the optional bool should be set to true if you are
including the program name in the string, and false otherwise.

Also, in a related note, the `App` you get a pointer to is stored in the parent `App` in a `shared_ptr`s (similar to `Option`s) and are deleted when the main `App` goes out of scope unless the object has another owner.

### How it works

Every `add_` option you have seen so far depends on one method that takes a lambda function. Each of these methods is just making a different lambda function with capture to populate the option. The function has full access to the vector of strings, so it knows how many times an option was passed or how many arguments it received. The lambda returns `true` if it could validate the option strings, and
`false` if it failed.

Other values can be added as long as they support `operator>>` (and defaults can be printed if they support `operator<<`). To add a new type, for example, provide a custom `operator>>` with an `istream` (inside the CLI namespace is fine if you don't want to interfere with an existing `operator>>`).

If you wanted to extend this to support a completely new type, use a lambda or add a specialization of the `lexical_cast` function template in the namespace `CLI::detail` with the type you need to convert to. Some examples of some new parsers for `complex<double>` that support all of the features of a standard `add_options` call are in [one of the tests](./tests/NewParseTest.cpp). A simpler example is shown below:

#### Example

```cpp
app.add_option("--fancy-count", [](std::vector<std::string> val){
    std::cout << "This option was given " << val.size() << " times." << std::endl;
    return true;
    });
```

### Utilities

There are a few other utilities that are often useful in CLI programming. These are in separate headers, and do not appear in `CLI11.hpp`, but are completely independent and can be used as needed. The `Timer`/`AutoTimer` class allows you to easily time a block of code, with custom print output.

```cpp
{
CLI::AutoTimer timer {"My Long Process", CLI::Timer::Big};
some_long_running_process();
}
```

This will create a timer with a title (default: `Timer`), and will customize the output using the predefined `Big` output (default: `Simple`). Because it is an `AutoTimer`, it will print out the time elapsed when the timer is destroyed at the end of the block. If you use `Timer` instead, you can use `to_string` or `std::cout << timer << std::endl;` to print the time. The print function can be any function that takes two strings, the title and the time, and returns a formatted
string for printing.

### Other libraries

If you use the excellent [Rang][] library to add color to your terminal in a safe, multi-platform way, you can combine it with CLI11 nicely:

```cpp
std::atexit([](){std::cout << rang::style::reset;});
try {
    app.parse(argc, argv);
} catch (const CLI::ParseError &e) {
    std::cout << (e.get_exit_code()==0 ? rang::fg::blue : rang::fg::red);
    return app.exit(e);
}
```

This will print help in blue, errors in red, and will reset before returning the terminal to the user.

If you are on a Unix-like system, and you'd like to handle control-c and color, you can add:

```cpp
 #include <csignal>
 void signal_handler(int s) {
     std::cout << std::endl << rang::style::reset << rang::fg::red << rang::fg::bold;
     std::cout << "Control-C detected, exiting..." << rang::style::reset << std::endl;
     std::exit(1); // will call the correct exit func, no unwinding of the stack though
 }
```

And, in your main function:

```cpp
     // Nice Control-C
     struct sigaction sigIntHandler;
     sigIntHandler.sa_handler = signal_handler;
     sigemptyset(&sigIntHandler.sa_mask);
     sigIntHandler.sa_flags = 0;
     sigaction(SIGINT, &sigIntHandler, nullptr);
```

## API

The API is [documented here][api-docs]. Also see the [CLI11 tutorial GitBook][gitbook].

## Examples

Several short examples of different features are included in the repository. A brief description of each is included here

 - [callback_passthrough](https://github.com/CLIUtils/CLI11/blob/master/examples/callback_passthrough.cpp): Example of directly passing remaining arguments through to a callback function which generates a CLI11 application based on existing arguments.
 - [digit_args](https://github.com/CLIUtils/CLI11/blob/master/examples/digit_args.cpp):  Based on [Issue #123](https://github.com/CLIUtils/CLI11/issues/123), uses digit flags to pass a value
 - [enum](https://github.com/CLIUtils/CLI11/blob/master/examples/enum.cpp):  Using enumerations in an option, and the use of [CheckedTransformer](#transforming-validators)
 - [formatter](https://github.com/CLIUtils/CLI11/blob/master/examples/formatter.cpp): Illustrating usage of a custom formatter
 - [groups](https://github.com/CLIUtils/CLI11/blob/master/examples/groups.cpp):  Example using groups of options for help grouping and a the timer helper class
 - [inter_argument_order](https://github.com/CLIUtils/CLI11/blob/master/examples/inter_argument_order.cpp): An app to practice mixing unlimited arguments, but still recover the original order.
 - [json](https://github.com/CLIUtils/CLI11/blob/master/examples/json.cpp):  Using JSON as a config file parser
 - [modhelp](https://github.com/CLIUtils/CLI11/blob/master/examples/modhelp.cpp):  How to modify the help flag to do something other than default
 - [nested](https://github.com/CLIUtils/CLI11/blob/master/examples/nested.cpp):  Nested subcommands
 - [option_groups](https://github.com/CLIUtils/CLI11/blob/master/examples/option_groups.cpp):  illustrating the use of option groups and a required number of options.
 based on [Issue #88](https://github.com/CLIUtils/CLI11/issues/88) to set interacting groups of options
 - [positional_arity](https://github.com/CLIUtils/CLI11/blob/master/examples/positional_arity.cpp): Illustrating use of `preparse_callback` to handle situations where the number of arguments can determine which should get parsed,  Based on [Issue #166](https://github.com/CLIUtils/CLI11/issues/166)
 - [positional_validation](https://github.com/CLIUtils/CLI11/blob/master/examples/positional_validation.cpp): Example of how positional arguments are validated using the `validate_positional` flag, also based on [Issue #166](https://github.com/CLIUtils/CLI11/issues/166)
 - [prefix_command](https://github.com/CLIUtils/CLI11/blob/master/examples/prefix_command.cpp): illustrating use of the `prefix_command` flag.
 - [ranges](https://github.com/CLIUtils/CLI11/blob/master/examples/ranges.cpp):  App to demonstrate exclusionary option groups based on [Issue #88](https://github.com/CLIUtils/CLI11/issues/88)
 - [shapes](https://github.com/CLIUtils/CLI11/blob/master/examples/shapes.cpp): illustrating how to set up repeated subcommands Based on [gitter discussion](https://gitter.im/CLI11gitter/Lobby?at=5c7af6b965ffa019ea788cd5)
 - [simple](https://github.com/CLIUtils/CLI11/blob/master/examples/simple.cpp): a simple example of how to set up a CLI11 Application with different flags and options
 - [subcom_help](https://github.com/CLIUtils/CLI11/blob/master/examples/subcom_help.cpp): configuring help for subcommands
 - [subcom_partitioned](https://github.com/CLIUtils/CLI11/blob/master/examples/subcom_partitioned.cpp): Example with a timer and subcommands generated separately and added to the main app later.
 - [subcommands](https://github.com/CLIUtils/CLI11/blob/master/examples/subcommands.cpp): Short example of subcommands
 - [validators](https://github.com/CLIUtils/CLI11/blob/master/examples/validators.cpp): Example illustrating use of validators

## Contribute

To contribute, open an [issue][github issues] or [pull request][github pull requests] on GitHub, or ask a question on [gitter][]. The is also a short note to contributors [here](./.github/CONTRIBUTING.md).
This readme roughly follows the [Standard Readme Style][] and includes a mention of almost every feature of the library. More complex features are documented in more detail in the [CLI11 tutorial GitBook][gitbook].

This project was created by [Henry Schreiner](https://github.com/henryiii).
Significant features and/or improvements to the code were contributed by:

-   [Anton](https://github.com/SX91)
-   [Doug Johnston](https://github.com/dvj)
-   [Jonas Nilsson](https://github.com/SkyToGround)
-   [Lucas Czech](https://github.com/lczech)
-   [Marcus Brinkmann](https://github.com/lambdafu)
-   [Mathias Soeken](https://github.com/msoeken)
-   [Nathan Hourt](https://github.com/nathanhourt)
-   [Sean Fisk](https://github.com/seanfisk)
-   [StÃ©phane Del Pino](https://github.com/delpinux)
-   [Mak Kolybabi](https://github.com/mogigoma)
-   [PaweÅ‚ Bylica](https://github.com/chfast)
-   [Philip Top](https://github.com/phlptp) <!-- Major features in 1.7 and 1.8 -->
-   [almikhayl](https://github.com/almikhayl)
-   [nurelin](https://github.com/nurelin) <!-- help_all in message -->
-   [ncihneg](https://github.com/ncihneg) <!-- Quoting strings in INI generation -->
-   [Fred HelmesjÃ¶](https://github.com/helmesjo) <!-- `->description()` -->
-   [Rafi Wiener](https://github.com/rafiw) <!-- INI, +ive validators and vector separators -->
    [elszon](https://github.com/elszon) <!-- Formatting in multiline string -->
    [ryan4729](https://github.com/ryan4729) <!-- AArch64 support -->
    [Andrew Hardin](https://github.com/andrew-hardin) <!-- Fixing two warnings -->
    [Paul le Roux](https://github.com/pleroux0) <!-- Arch independent CMake Config -->
-   [Viacheslav Kroilov](https://github.com/metopa) <!-- AsNumberWithUnit and AsSizeValue -->


## License

As of version 1.0, this library is available under a 3-Clause BSD license. See the [LICENSE](./LICENSE) file for details.

CLI11 was developed at the [University of Cincinnati][] to support of the [GooFit][] library under [NSF Award 1414736][]. Version 0.9 was featured in a [DIANA/HEP][] meeting at CERN ([see the slides][diana slides]). Please give it a try! Feedback is always welcome.

[doi-badge]: https://zenodo.org/badge/80064252.svg
[doi-link]: https://zenodo.org/badge/latestdoi/80064252
[azure-badge]: https://dev.azure.com/CLIUtils/CLI11/_apis/build/status/CLIUtils.CLI11?branchName=master
[azure]: https://dev.azure.com/CLIUtils/CLI11/_build/|latest?definitionId=1&branchName=master
[travis-badge]: https://img.shields.io/travis/CLIUtils/CLI11/master.svg?label=Linux/macOS
[travis]: https://travis-ci.org/CLIUtils/CLI11
[appveyor-badge]: https://img.shields.io/appveyor/ci/HenrySchreiner/cli11/master.svg?label=Windows
[appveyor]: https://ci.appveyor.com/project/HenrySchreiner/cli11
[codecov-badge]: https://codecov.io/gh/CLIUtils/CLI11/branch/master/graph/badge.svg
[codecov]: https://codecov.io/gh/CLIUtils/CLI11
[gitter-badge]: https://badges.gitter.im/CLI11gitter/Lobby.svg
[gitter]: https://gitter.im/CLI11gitter/Lobby
[license-badge]: https://img.shields.io/badge/License-BSD-blue.svg
[conan-badge]: https://api.bintray.com/packages/cliutils/CLI11/CLI11%3Acliutils/images/download.svg
[conan-link]: https://bintray.com/cliutils/CLI11/CLI11%3Acliutils/_latestVersion
[github releases]: https://github.com/CLIUtils/CLI11/releases
[github issues]: https://github.com/CLIUtils/CLI11/issues
[github pull requests]: https://github.com/CLIUtils/CLI11/pulls
[goofit]: https://GooFit.github.io
[plumbum]: https://plumbum.readthedocs.io/en/latest/
[click]: http://click.pocoo.org
[api-docs]: https://CLIUtils.github.io/CLI11/index.html
[rang]: https://github.com/agauniyal/rang
[boost program options]: http://www.boost.org/doc/libs/1_63_0/doc/html/program_options.html
[the lean mean c++ option parser]: http://optionparser.sourceforge.net
[tclap]: http://tclap.sourceforge.net
[cxxopts]: https://github.com/jarro2783/cxxopts
[docopt]: https://github.com/docopt/docopt.cpp
[gflags]: https://gflags.github.io/gflags
[getopt]: https://www.gnu.org/software/libc/manual/html_node/Getopt.html
[diana/hep]: http://diana-hep.org
[nsf award 1414736]: https://nsf.gov/awardsearch/showAward?AWD_ID=1414736
[university of cincinnati]: http://www.uc.edu
[gitbook]: https://cliutils.gitlab.io/CLI11Tutorial
[cli11 internals]: https://cliutils.gitlab.io/CLI11Tutorial/chapters/internals.html
[programoptions.hxx]: https://github.com/Fytch/ProgramOptions.hxx
[argument aggregator]: https://github.com/vietjtnguyen/argagg
[args]: https://github.com/Taywee/args
[argh!]: https://github.com/adishavit/argh
[fmt]: https://github.com/fmtlib/fmt
[catch]: https://github.com/philsquared/Catch
[clara]: https://github.com/philsquared/Clara
[version 1.0 post]: https://iscinumpy.gitlab.io/post/announcing-cli11-10/
[version 1.3 post]: https://iscinumpy.gitlab.io/post/announcing-cli11-13/
[version 1.6 post]: https://iscinumpy.gitlab.io/post/announcing-cli11-16/
[wandbox-badge]: https://img.shields.io/badge/try_1.8-online-blue.svg
[wandbox-link]: https://wandbox.org/permlink/EbI6nT3RkYKviKV2
[releases-badge]: https://img.shields.io/github/release/CLIUtils/CLI11.svg
[cli11-po-compare]: https://iscinumpy.gitlab.io/post/comparing-cli11-and-boostpo/
[diana slides]: https://indico.cern.ch/event/619465/contributions/2507949/attachments/1448567/2232649/20170424-diana-2.pdf
[awesome c++]: https://github.com/fffaraz/awesome-cpp/blob/master/README.md#cli
[cli]: https://codesynthesis.com/projects/cli/
[single file libs]: https://github.com/nothings/single_file_libs/blob/master/README.md
[codacy-badge]: https://api.codacy.com/project/badge/Grade/ac0df3aead2a4421b02070c3f324a0b9
[codacy-link]: https://www.codacy.com/app/henryiii/CLI11?utm_source=github.com&utm_medium=referral&utm_content=CLIUtils/CLI11&utm_campaign=Badge_Grade
[hunter]: https://docs.hunter.sh/en/latest/packages/pkg/CLI11.html
[standard readme style]: https://github.com/RichardLitt/standard-readme
[argparse]: https://github.com/p-ranav/argparse
